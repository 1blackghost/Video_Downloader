'''
Module used to work with youtube downloading videos and audios.
'''
from pytube import YouTube
import re
import threading


class Y_D:
    '''
    Main class of youtube downloader
    Arguments Expected: url

    '''
    def __init__(self,url):
        self.url=url
        self.yt = YouTube(self.url)
    def get_title(self):
        '''
        Returns the title of the youtube video
        
        returnType:str
        '''
        return self.yt.title
    def check_available(self):
        '''
        This function checks all the res and formats available and return a dictionary of data
        that can be able to work with python,most of the objects cannot be found in stream are
        extracted using split method

        returnType:dictionary
        
        avg resp time:2s-3s

        sample return value:
        {'video': 
            {'"144p"': ['video/webm', 'video', False], 
            '"360p"': ['video/webm', 'video', False], 
            '"720p"': ['video/webm', 'video', False], 
            '"2160p"': ['video/webm', 'video', False], 
            '"1440p"': ['video/webm', 'video', False], 
            '"1080p"': ['video/webm', 'video', False], 
            '"480p"': ['video/webm', 'video', False], 
            '"240p"': ['video/webm', 'video', False]}, 
        'audio': 
            {'48kbps': ['audio/mp4', 'audio'], 
            '128kbps': ['audio/mp4', 'audio'], 
            '50kbps': ['audio/webm', 'audio'], 
            '70kbps': ['audio/webm', 'audio'], 
            '160kbps': ['audio/webm', 'audio']
            }
        }
        '''
        d={}
        #for video dictinary
        d_video={}
        #for audio dictionary
        d_audio={}
        for stream in self.yt.streams:
            data=[]
            type=stream.type
            data.append(stream.mime_type)
            #if the type is video appends into video dict
            if str(type)=="video":
                data.append(type)
                res=str(stream).split(" ")[3].split("=")[1]
                data.append(stream.is_progressive)
                d_video[res]=data
            #otherwise audio dictionary
            elif str(type)=="audio":
                data.append(stream.type)
                d_audio[stream.abr]=data
        #appending to the parent dictionary audio and video dictionary
        #Timsort algorithm with an average case performance of O(n log n),
        #it's unlikely that the performance impact of sorting will be noticeable.
        #A simple ascending ordered sort to produce quality in order.
        ''' Thanks to ChatGPT'''
        #video res sort
        sortedDict = {}
        for key in sorted(d_video.keys(), key=lambda x: int(x.strip('"')[:-1])):
            sortedDict[key] = d_video[key]
        d["video"]=sortedDict
        #audio res sort
        sortedDict = {}
        pattern = re.compile(r'\d+')
        for key in sorted(d_audio.keys(), key=lambda x: int(pattern.search(x).group())):
            sortedDict[key] = d_audio[key]

        d["audio"]=sortedDict 
        return d

    def start_download(self,res,data):
        if data[1]=="video":
            self.yt.streams.filter(res=res,mime_type=data[0],progressive=data[2]).first().download("static")
        
        elif data[1]=="audio":
            self.yt.streams.filter(abr=res,mime_type=data[0]).first().download("static")

    def download(self,res,data):
        '''
        Downloads youtube video/audio in the passed formats
        
        expected arguments:res|abr:str , data :list(in order generated by check_available)
        returnType:None
        '''
        t=threading.Thread(target=self.start_download,args=(res,data))
        t.start()
        return 0